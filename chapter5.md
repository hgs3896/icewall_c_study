# 5 주차

5주차 : 위치 값 / 배열 / 인덱스, 1차원 배열, 2차원 배열, char 배열 배우기, buffer overflow 취약점 이해하기

위치 값이라는 것은 무엇일까? 파이썬과 같은 다른 프로그래밍 언어를 잘 공부했다면 우리가 흔히 변수라고 부르는 것들은 소위 이름을 통해 해당 이름에 연결되는 object\(쉽게 생각해서 메모리에 존재하는 **어떤 칸**이라 봅시다\) 하나를 얻을 수 있는 수단으로 알고 계시겠죠? 그럼 그 object가 메모리 어디에 있는 지와 같은 **위치\(물리적으로 절대적인 위치는 아님\)**는 C에서 해당 이름에 &를 앞에 붙여서 얻을 수 있습니다.

```
int x;
&x; // x라는 이름이 연결된 실재하는 칸의 위치 값
```

해당 칸에 대해 이 위치 정보는 **하나의 값** 이므로 이제부터 **위치 값**이라고 부르겠습니다.

그리고 6주차에 이 값을 보다 ~~유쾌하게~~ 다루도록 해주는 도구인 포인터를 소개하겠습니다.

위치 값을 먼저 소개해 드린 이유는 배열이라는 친구가 이 위치값을 이용해 다양한 연산을 해낼 수 있기 때문입니다.



우선, **배열**이란. 하나의 이름\(배열명\)으로 동일한 형식의 object들을 연속적으로 담는 **공간**입니다.

배열을 만들기 위해서는 변수나 함수와 마찬가지로 배열을 선언해야합니다.

```
int arr[10]; // int형식의 칸 10개로 된 배열을 선언
int arr2[5] = {3, 2, 1, 6, 9}; // int형식의 칸 5개로 된 배열을 선언하고 각각의 object를 3 2 1 6 9로 초기화하기
int arr3[5] = {1, }; // 이렇게 적으면 0번째 칸은 1로, 나머지 칸은 0으로 초기화 돼요.
int arr4[10] = {} // 이것은 declarator에 해당하지 않습니다. 반드시 하나 이상의 수식을 적어야해요.
```

아래와 같은 그림은 위 선언을 통해 구성된 배열의 모식적인 모습입니다.

| int | int | int | int | int | int | int | int | int | int |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |  |  |  |  |

이제부터 하나의 이름\(arr\)을 이용해서 각각의 int형식 object를 사용할 수 있도록 새로운 연산자를 배워봅시다.

배열명\[정수 수식\]

라는 수식을 쓰게 되면, 배열의 몇 번 째 원소에 있는 object를 정확히 하나 선택할 수 있습니다.

따라서, arr\[3\]라는 수식은 세번 째 칸이 아닌 0부터 세기 시작하여에 위치한  3번 째에 위치한 int 형식 object를 의미 할 수 있는 것이죠.

그렇다면 10명의 학생의 소입설 점수를 입력받아 **평균과 분산**을 구해주는 프로그램을 만들어봅시다.

평균과 분산이 뭔지 모를 친구들을 위해, 간단히 설명하면 평균은 변량의 합을 변량의 개수로 나눈 것이고, 분산은 편차\(변량을 평균으로 뺀 값\) 제곱의 평균을 의미합니다.

avg = \(Average\) = \(_x\_1 _+_ x\_2 _+_ ... _+_ x\_N\) / N_

_v = \(Variance\) = \( \(x\_1 - avg\)^2 + \(x\_2 - avg\)^2 + ... + \(x\_N - avg\)^2 \) / N_

그렇다면, 10명의 점수에 해당하는 변수를 하나하나 만들어서 scanf로 입력을 받아야할까요?

만약 10명이 아니라 1000명이라면 너무 끔찍한 일이 될 것입니다.

따라서 배열을 사용하면 하나의 이름으로 여러 칸을 편리하게 다룰 수 있게 됩니다.

아래의 코드를 복사해서 10명의 학생들의 소입설 성적의 평균과 분산을 구하는 프로그램을 만들어봅시다.

```
#include <stdio.h>
#include <math.h>

int main(void)
{
    int i;
    printf("10개의 성적을 입력해주세요.\n");
    /* 평균과 분산 */
    double avg = 0.0, var = 0.0;
    int arr[10];
    for ( i = 0; i < 10; i = i + 1 )
    {
        scanf("%d", &arr[i]);
    }
    /* 평균과 분산을 구하는 코드를 작성해주세요. */
    printf("%10s : %-10.3lf\n"
           "%10s : %-10.3lf\n"
           "%10s : %-10.3lf\n"
           , "평균", avg
           , "분산", var
           , "표준 편차", sqrt(var));
}
```

또한, 배열은 같은 자료형을 담는 연속적인 메모리 공간이기 때문에, char 형식 object를 담는 배열을 만들 수 있겠죠?

char str\[6\]; //char형식 object 6개 선언

str\[0\] = 'k';

str\[1\] = 'o';

str\[2\] = 'r';

str\[3\] = 'e';

str\[4\] = 'a';



그렇다면, printf\("%s", str\);의 결과는?



아직 배우지는 않았지만, C에서 함수의 인자로 값을 넘길때에는 반드시 **한 번에 한 칸의 값**만을 **복사**할 수 있어요. \(예외가 있긴해요.\)

그래서 str을 printf의 함수의 인자로 값을 넘기게 되면, str 배열 각각의 object들의 값\(문자들\)들이 복사되지 않고, str의 0번째 object의 위치 값을 복사해요.



그럼 int나 다른 형식의 값들도 그렇게 전달되나요라고 묻는다면, 아니에요.

그 이유는 배열의 경우 여러 칸의 내용을 다룰 수 있기 때문에, 함수를 매번 호출 할 때마다 배열의 모든 내용을 복사하는 작업은 매우 자원낭비에요. 

따라서 배열의 경우, **배열의 이름**만 적었을 때 그 **배열의 0번째 object의 위치 값을 나타내는 수식**으로 사용할 수 있어요.

아니 이게 무슨 ~~귀신씻나라까먹고설레발치는~~ 말이냐 하면, `str == &str[0]` 가 성립한다는 의미에요.

그렇기에 실제 함수에 전달되는 값은 배열의 첫번 째 원소의 위치 값만이 전달돼요.

그럼 배열의 0번 째 object의 위치값만 알고있으면 배열 전체의 크기를 알 수 있을까요?

알 수가 없어요.!

그래서, 문자 배열의 경우에는 문자열의 끝을 나타내는 문자를 가장 마지막에 담아서 쓰이도록 했어요.

문자열의 끝을 나타내는 문자는 바로 널 문자이며, '\0' 이런 식의 문자에요.

이 또한 하나의 char형 상수이기에 유효한 수식이고, int형식으로 바꾸어 본다면 0으로 볼  수도 있어요.



char 배열 str1

| 'k' | 'o' | 'r' | 'e' | 'a' | 'n' |
| :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |

char 배열 str2

| 'k' | 'o' | 'r' | 'e' | 'a' | '\0' |
| :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |

str1은 1번의 예시이고, str2는 2번의 예시이다

char 배열에서 문자들의 가장 끝에 널문자 \(\0\)가 들어가야만 문자열로 인식이 된다.

그렇기 때문에 문자열을 담는 char 배열의 크기는 항상 \(문자개수+1\) 이상이어야 한다.

문자열인 char 배열의 경우 c언어의 string 헤더를 이용한 여러가지 문자열 함수를 사용할 수 있다.

문자열을 선언하는 방법에 대해 보자.

```
char str[] = "hello" // 알아서 크기가 6만큼 할당된다. 'o' 다음에 널문자인 '\0'이 알아서 들어 감. 
char str2[6] = "hello" // 직접 크기를 6으로 할당하고 넣어준다.

// str과 str2는 같은 구조이다.

char day[4];
day[0] = 'd';
day[1] = 'a';
day[2] = 'y';

// 이때의 char 배열은 공백문자를 할당하지 않았기 때문에 문자열이 아니다. 문자열이 아닌 char배열이다.

day[3] = '\0'
//이렇게 마지막에 널문자를 넣어준다면, 문자열로 인식할 수 있다.
```

그냥 char배열과 문자열의 차이를 알아보자면,

```
#include<stdio.h>

int main(void) {
    char str[] = "hello";
    char fruits[5]= {'a','p','p','l','e'};
    for(int i=0 ; i<5 ; i++)
        printf("%c", fruits[i]);
        //배열에 접근해서 하나씩 출력
    printf("\n");

    printf("%s\n",str);//문자열의 출력 문자로 한번에 출력.

}
```

문자열을 입력받을 때는

```
#include<stdio.h>

int main(void) {
    char fruits[6];
    scanf("%s",fruits);
    printf("%s\n",fruits);
    return 0;
}
```

%s 로 입력을 받으면, 알아서 공백문자가 추가되어 저장된다.

#### 

_**이제 문자열 관련 함수를 배우자.**_

**strcpy**\( char 배 , 복사해서 붙여넣을 문자열\);

-&gt; 문자열을 복사해서 붙여주는 함수.

이 함수의 리턴 형태는 문자열 형태이다.

```
#include <stdio.h>
#include <string.h>
int main(){    
    char name[10];    
    strcpy(name,"LZena");    
    printf("입력된 문자열 : %s ",name);    
    return 0;
}
```

###### 

**strlen**\(문자열\);

-&gt; 문자열의 길이를 반환하는 함수\(리턴 형태는 unsigned int\)

```
#include <stdio.h>
#include <string.h>
int main(){    
    char name[10] = "yurim";        
    printf("문자열 길이 : %d \n",strlen(name));
    printf("배열의 길이 : %d \n", sizeof(name));    
    return 0;
}
```

###### 

**strcmp**\( 문자1, 문자열2\);

-&gt;문자열 두개를 비교해 같으면 0을, 문자1이 작으면 -1, 문자1이 크면 1을 반환합니다.

대 ,소문자를 구분하며 알파벳 순으로 비교했을 때 크다, 작다를 말합니다.

```
#include <stdio.h>
#include <string.h>
int main()
{
    char str1[20]="apple";
    char str2[20]="banana";
    printf("apple : banana반환 값 : %d\n",strcmp(str1,str2));

    strcpy(str2,"apple");
    printf("apple : apple 반환 값 : %d\n",strcmp(str1,str2));

    strcpy(str1,"cherry");
    printf("cherry : apple반환 값 : %d\n",strcmp(str1,str2));
    return 0;
}
```

##### 

---

###### 

##### 지금까지 1차원, 2차원 배열, char 배열에 대해 알아보았다. {#지금까지-1차원-2차원-배열-char-배열에-대해-알아보았다}

##### 그렇다면, 보안동아리 답게 배열을 사용할 때 발생하는 취약점에 대해 배워보자. {#그렇다면-보안동아리-답게-배열을-사용할-때-발생하는-취약점에-대해-배워보자}

#### 

‘버퍼 오버플로우’는 프로그램이 메모리를 잘못 다뤄서 오류를 일으키거나 프로그램 보안 취약점을 야기시키는 결함입니다.

buffer는 일종의 메모리 저장장치의 일종이라고 생각합시다. buffer에서 overflow\(홍수\)가 난다.

즉, 할당받은 메모리를 넘어가서 다른 데이터를 침범하게 되는 것이다.

###### 

![](https://newrim.gitbooks.io/c-study_icewall/content/assets/스크린샷 2017-05-09 오후 4.30.05.png)picoctf라는 입문자용 ctf의 bufferoverflow 문제를 보며 좀 더 알아보자.

자세한 문제는 shell을 통해 보자.

###### ![](https://newrim.gitbooks.io/c-study_icewall/content/assets/shell.png)

###### 

shell을 통해 picoctf서버에 접속을 하면,

Your number is 4682229. Can you make it negative by adding a postive integer? 라는 문제가 나온다.

이때 어떤 양의 정수를 더해야, 음수로 만들 수 있는지 알아내서 입력을 하면 congratulations! 라는 문구를 볼 수 있다.

###### 

예전에 비트 연산자를 배우면서 부호 비트라는 개념에 대해 들어봤을 것이다.

임의의 int 변수 num 은 총 32bit\(4byte\)로 이루어져 있으며, 맨 앞의 비트는 부호비트\(0이면 양수, 1이면 음수\)이다.

int의 표현 가능 범위는 -2147483647 ~ 2147483647이다.

| 0\(부\) | 0 | 1 | 1 | ... | ... | ... | ... | 0 | 1 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |  |  |  |  |

이런식의 이진데이터\(int형\)에서 내가 만약 int의 최대 표현 값인 2147483647를 더한다면, int의 표현 범위를 넘어갈 것이다.

그렇게 되면 제일 왼쪽의 비트인 부호비트에 까지 자리올림이 발생해 1로 바뀌게 된다.

이렇게 되면, 부호 비트가 1로 바뀌기 때문에 음수가 되어버리는 것이다.

###### 

이 문제는 버퍼 오버플로우 문제 중에서 간단한 축에 속하고, 여러가지 응용을 통해 프로그램의 권한을 취득하는 등 악용할 수 있다.

모범 답안

```
#include <stdio.h>
#include <math.h>

int main(void)
{
    int i;
    printf("10개의 성적을 입력해주세요.\n");
    /* 평균과 분산 */
    double avg = 0.0, var = 0.0;
    int arr[10];
    for ( i = 0; i < 10; i = i + 1 )
    {
        scanf("%d", &arr[i]);
        avg += arr[i];
        var += arr[i] * arr[i];
    }
    avg = avg / 10;
    var = var / 10;
    var = var - avg * avg;
    printf("%10s : %-10.3lf\n"
           "%10s : %-10.3lf\n"
           "%10s : %-10.3lf\n"
           , "평균", avg
           , "분산", var
           , "표준 편차", sqrt(var));
}
```



