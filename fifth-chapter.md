# 5 주차



5주차 : 1차원 배열, 2차원 배열, char 배열 배우기, buffer overflow 취약점 이해하기

배열이란 하나의 이름으로 참조되는 같은 자료형을 담는 메모리의 연속적 공간을 말한다.아래와 같은 그림은 int형 데이터를 담는 연속적인 공간, int형 배열이다.

| int | int | int | int | int | int | int | int | int | ... |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |  |  |  |  |

###### 

그렇다면,배열을 사용하는 이유는 무엇일까?

프로그램을 구성하다 보면,동일한 속성을 갖는 여러개의 변수를 사용하는 상황이 발생한다.

10명의 학생의 소입설 점수를 입력받아서 저장하는 프로그램을 만든다고 해보자.

```
#include<stdio.h>

int main(void) {
    int stu1, stu2, stu3, stu4, stu5, stu6, stu7, stu8, stu9, stu10;
    scanf("%d",&stu1);
    scanf("%d",&stu2);
            .
            .
            .
    scanf("%d",&stu10)
    return 0;
}
```

그렇다면,이렇게 10명의 변수를 하나하나 만들어서 scanf로 입력을 받아야할까?

이것은 너무 끔찍한 일이다.그렇기 때문에배열을 사용한다.여러 개의 데이터에 대해 관리하는 일이 쉬워진다.

이러한 배열에는 1차원과, 2차원 배열 등...이 있다.우리는 2차원 까지만 배워보자.

1차원 배열의 사용방법은 다음 코드를 보며 이해해 보자.

```
#include<stdio.h>

int main(void) {
    int stu[10];
    for(int i=0 ; i<10 ; i++) {
        scanf("%d", &stu[i]);

    for(int i=0 ; i<10 ; i++) {
        printf("%d\n",stu[i]);
    return 0;
}
```

1차원 배열의 선언 방식은 다음과 같다.

_자료형 배열이름\[만들 데이터의 개수\];_

int stud\[10\];이렇게 선언을 한다면!

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| data | data | data | data | data | data | data | data | data | data |

stud\[0\]를 이용하면, stud라는 배열에 있는 0번째 요소에 있는 데이터를 사용할 수 있는 것이다.

###### 

그렇다면,**2차원 배열**은 무엇일까? 말 그대로 1차원에서 한 차원이 높아진 것이다.

좌표계로 이해를 한다면, 1차원은 x좌표로만 움직이는 것이고 2차원은 y 좌표가 추가로 생기는 것이다.

###### 2차원 배열은 선언은 방식은 다음과 같다. {#2차원-배열은-선언은-방식은-다음과-같다}

###### _자료형 배열이름\[행의 개수\]\[열의 개수\];_ {#자료형-배열이름행의-개수열의-개수}

|  | 0 | 1 | 2 | 3 |
| :--- | :--- | :--- | :--- | :--- |
| 0 | data | data | data | data |
| 1 | data | data | data | data |
| 2 | data | data | data | data |
| 3 | data | data | data | data |

위의 2차원 배열이 int arr\[4\]\[4\]라고 했을 때,

arr\[2\]\[0\]를 이용하면, arr의 2행 0열에 들어있는 데이터에 접근할 수 있다.

이제 예제를 통해 더 사용법에 대해 더 익혀보자.

###### 

**! 한 층에 3가구 씩 4층 짜리 아파트가 있다. 각 세대 별로 인구 수 를 입력받은 후, 몇 층에 몇명이 사는지 알아 볼수 있는 프로그램을 만들어 보자.**

```
#include<stdio.h>

int main(void) {
    int apart[4][3];


    for(int i=0 ; i<4 ; i++) {
        //행에 접근하기 위한 반복
        for(int j=0 ; j<3 ; j++) {
            // 열에 접근하기 위한 반복
            scanf("%d",&apart[i][j]);
        }
    }
    int sum=0;
    int op=0;
    while(1) {
        sum=0;
        printf("몇 층의 인구를 알아볼까요? ");
        scanf("%d",&op);//
        if(op==-1)
            break;
        for(int i=0 ; i<3 ; i++) {
            sum += apart[op][i];
        }
        printf("총 %d명\ㅜㅜn"sum);
    }

    return 0;
}
```

##### 

---

###### 

이번에는 1차원 배열 중에서 int형이 아닌 char 배열에 대해 더 알아보자.

배열은 같은 자료형을 담는 연속적인 메모리 공간이기 때문에, char 자료형으로도 충분히 배열을 만들 수 있다.

char배열은 두가지 종류가 있다.

1. 문자들이 모인 덩어리
2. 문자열

1번의 경우는 그냥 char 자료형을 가지 문자들의 나열일 뿐이다. 하지만 2번의 경우는 그 문자들의 나열이 하나의 문자열\(string\) 으로 취급 될 수 있는 것 이다.

###### 

char 배열 str1

| 'k' | 'o' | 'r' | 'e' | 'a' | 'n' |
| :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |

char 배열 str2

| 'k' | 'o' | 'r' | 'e' | 'a' | '\0' |
| :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |

str1은 1번의 예시이고, str2는 2번의 예시이다

char 배열에서 문자들의 가장 끝에 널문자 \(\0\)가 들어가야만 문자열로 인식이 된다.

그렇기 때문에 문자열을 담는 char 배열의 크기는 항상 \(문자개수+1\) 이상이어야 한다.

문자열인 char 배열의 경우 c언어의 string 헤더를 이용한 여러가지 문자열 함수를 사용할 수 있다.

문자열을 선언하는 방법에 대해 보자.

```
char str[] = "hello" // 알아서 크기가 6만큼 할당된다. 'o' 다음에 널문자인 '\0'이 알아서 들어 감. 
char str2[6] = "hello" // 직접 크기를 6으로 할당하고 넣어준다.

// str과 str2는 같은 구조이다.

char day[4];
day[0] = 'd';
day[1] = 'a';
day[2] = 'y';

// 이때의 char 배열은 공백문자를 할당하지 않았기 때문에 문자열이 아니다. 문자열이 아닌 char배열이다.

day[3] = '\0'
//이렇게 마지막에 널문자를 넣어준다면, 문자열로 인식할 수 있다.
```

그냥 char배열과 문자열의 차이를 알아보자면,

```
#include<stdio.h>

int main(void) {
    char str[] = "hello";
    char fruits[5]= {'a','p','p','l','e'};
    for(int i=0 ; i<5 ; i++)
        printf("%c", fruits[i]);
        //배열에 접근해서 하나씩 출력
    printf("\n");

    printf("%s\n",str);//문자열의 출력 문자로 한번에 출력.

}
```

문자열을 입력받을 때는

```
#include<stdio.h>

int main(void) {
    char fruits[6];
    scanf("%s",fruits);
    printf("%s\n",fruits);
    return 0;
}
```

%s 로 입력을 받으면, 알아서 공백문자가 추가되어 저장된다.

#### 

_**이제 문자열 관련 함수를 배우자.**_

**strcpy**\( char 배 , 복사해서 붙여넣을 문자열\);

-&gt; 문자열을 복사해서 붙여주는 함수.

이 함수의 리턴 형태는 문자열 형태이다.

```
#include <stdio.h>
#include <string.h>
int main(){    
    char name[10];    
    strcpy(name,"LZena");    
    printf("입력된 문자열 : %s ",name);    
    return 0;
}
```

###### 

**strlen**\(문자열\);

-&gt; 문자열의 길이를 반환하는 함수\(리턴 형태는 unsigned int\)

```
#include <stdio.h>
#include <string.h>
int main(){    
    char name[10] = "yurim";        
    printf("문자열 길이 : %d \n",strlen(name));
    printf("배열의 길이 : %d \n", sizeof(name));    
    return 0;
}
```

###### 

**strcmp**\( 문자1, 문자열2\);

-&gt;문자열 두개를 비교해 같으면 0을, 문자1이 작으면 -1, 문자1이 크면 1을 반환합니다.

대 ,소문자를 구분하며 알파벳 순으로 비교했을 때 크다, 작다를 말합니다.

```
#include <stdio.h>
#include <string.h>
int main()
{
    char str1[20]="apple";
    char str2[20]="banana";
    printf("apple : banana반환 값 : %d\n",strcmp(str1,str2));

    strcpy(str2,"apple");
    printf("apple : apple 반환 값 : %d\n",strcmp(str1,str2));

    strcpy(str1,"cherry");
    printf("cherry : apple반환 값 : %d\n",strcmp(str1,str2));
    return 0;
}
```

##### 

---

###### 

##### 지금까지 1차원, 2차원 배열, char 배열에 대해 알아보았다. {#지금까지-1차원-2차원-배열-char-배열에-대해-알아보았다}

##### 그렇다면, 보안동아리 답게 배열을 사용할 때 발생하는 취약점에 대해 배워보자. {#그렇다면-보안동아리-답게-배열을-사용할-때-발생하는-취약점에-대해-배워보자}

#### 

‘버퍼 오버플로우’는 프로그램이 메모리를 잘못 다뤄서 오류를 일으키거나 프로그램 보안 취약점을 야기시키는 결함입니다.

buffer는 일종의 메모리 저장장치의 일종이라고 생각합시다. buffer에서 overflow\(홍수\)가 난다.

즉, 할당받은 메모리를 넘어가서 다른 데이터를 침범하게 되는 것이다.

###### 

![](https://newrim.gitbooks.io/c-study_icewall/content/assets/스크린샷 2017-05-09 오후 4.30.05.png)picoctf라는 입문자용 ctf의 bufferoverflow 문제를 보며 좀 더 알아보자.

자세한 문제는 shell을 통해 보자.

###### ![](https://newrim.gitbooks.io/c-study_icewall/content/assets/shell.png)

###### 

shell을 통해 picoctf서버에 접속을 하면,

Your number is 4682229. Can you make it negative by adding a postive integer? 라는 문제가 나온다.

이때 어떤 양의 정수를 더해야, 음수로 만들 수 있는지 알아내서 입력을 하면 congratulations! 라는 문구를 볼 수 있다.

###### 

예전에 비트 연산자를 배우면서 부호 비트라는 개념에 대해 들어봤을 것이다.

임의의 int 변수 num 은 총 32bit\(4byte\)로 이루어져 있으며, 맨 앞의 비트는 부호비트\(0이면 양수, 1이면 음수\)이다.

int의 표현 가능 범위는 -2147483647 ~ 2147483647이다.

| 0\(부\) | 0 | 1 | 1 | ... | ... | ... | ... | 0 | 1 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
|  |  |  |  |  |  |  |  |  |  |

이런식의 이진데이터\(int형\)에서 내가 만약 int의 최대 표현 값인 2147483647를 더한다면, int의 표현 범위를 넘어갈 것이다.

그렇게 되면 제일 왼쪽의 비트인 부호비트에 까지 자리올림이 발생해 1로 바뀌게 된다.

이렇게 되면, 부호 비트가 1로 바뀌기 때문에 음수가 되어버리는 것이다.

###### 

이 문제는 버퍼 오버플로우 문제 중에서 간단한 축에 속하고, 여러가지 응용을 통해 프로그램의 권한을 취득하는 등 악용할 수 있다.

