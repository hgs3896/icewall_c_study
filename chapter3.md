# 3 주차 {#3-주차}

3주차 : 출력 형식 가르치기, 조건문 배우기, 기타 연산자들\(비트, 논리\)

오늘은 지난번에 배운 기본 출력 형식\( 예를 들면, %d \) 들을 응용해 봅시다.

우선 정수형 데이터들 부터!

```
#include <stdio.h>


int main(void)
{
    int a=-5, b=23, c=5376;
    long d=325678;
    printf("정수형숫자format\n");
    printf(" 1. a=%d\n", a);
    printf(" 2. a=%6d\n", a); // 오른쪽맞춤
    printf(" 3. a=%06d\n", a); // 오른쪽맞춤
    printf(" 4. b=%6d\n", b);
    printf(" 5. b=%+6d\n", b); // 부호표시
    printf(" 6. c=%6d\n", c);
    printf(" 7. c=%-6d\n", c); // 왼쪽맞춤
    printf(" 8. d=%6ld\n", d); // 오른쪽맞춤
    return 0;
}
```

# ![](https://newrim.gitbooks.io/c-study_icewall/content/assets/ㅁㄴ.png)

정수형 숫자에 대해 자릿수를 맞추어 출력할 수 있다. %ⓝd 같은 형식으로 사용을하고 ⓝ은 출력할 전체 자릿수를 의미한다.

##### 

실행화면과 코드를 함께 보면서 이해해보자.

%6d는 6칸이 있다고 가정할 때, 오른 쪽 정렬을 해서 출력하겠다는 뜻이다.

이제 %06d라고 하면, 값을 출력하고 남는 칸에 0을 집어넣겠다는 뜻이다.

왼쪽으로 정렬을 하고 싶다면 -를 붙여서 %-6d라고 쓰면 된다.

양의 정수에 굳이 부호를 표시하고 싶다면, %+6d를 사용하면 된다.

##### 

이번에는 실수형 데이터들을 살펴보자.

%ⓝ.ⓓd 의 형식으로 출력할 수 있구 ⓝ은 소숫점을 포함하여 출력할 전체 자릿수 ⓓ는 소숫점 이하 자릿수를 의미한다.

```
#include <stdio.h>

int main(void)
{
    float a=-437.46, b=1278.9;
    double c=5.567;
    printf("실수형숫자format \n");
    printf(" 1. a=%8.3f\n", a);
    printf(" 2. b=%8.3f\n", b); // 오른쪽맞춤
    printf(" 3. c=%-8.3f\n", c); // 왼쪽 맞춤
    printf(" 4. c=%8.f\n", c); // 오른쪽맞춤
    printf(" 5. c=%8.1f\n", c);
    printf(" 6. c=%.2f\n", c);
    printf(" 7. a=%+.2f\n", a);
    printf(" 8. b=%+.2f\n ", b); // 부호표시
    return 0;
}
```

![](https://newrim.gitbooks.io/c-study_icewall/content/assets/36068914-c5e0-4c9e-bc50-6a73fb0b56f7.png)

기본적으로 정수형 출력 포맷 응용방식과 크게 다르지 않다.

소숫점을 몇째자리까지 정할지 정할 수 있는게 추가된 것 뿐이다.

##### 

---

###### 

여기까지 출력형식의 응용방법에 대해 알아보았다!

#### 이제 새로운 개념**조건문**에 대해 배워보자! {#이제-새로운-개념-조건문에-대해-배워보자}

조건문이란, 특정 조건에 대해 참 거짓을 판단한 후에 기능을 정하는 문법이다.

어떤 형식으로 작성해야 하는지는 예제를 보며 알아보자.

```
#include<stdio.h>

int main(void) {
    int num1, num2;
    scanf("%d %d",&num1, &num2);

    if(num1 > num2) {
        printf("num1 이 더 크다!\n");
    } else if(num1 < num2){
        printf("num2 가 더 크다!\n");
    } else {
        printf("num1과 num2가 같다!\n");
    }

    return 0;
}
```

기본적인 형태는

if\( 참, 거짓을 판단할 수 있는 조건 \) {

```
   조건이 참일 경우 실행할 구문.
```

}

이다.

이제 응용을 하자면

_if\( 참, 거짓을 판단할 수 있는 조건 \) {_

_조건이 참일 경우 실행할 구문._

_} else {_

_if 조건외의 모든 상황에서 실행할 구문._

_}_

**이런 형태와**

_if\( 참, 거짓을 판단할 수 있는 조건 \) {_

_조건이 참일 경우 실행할 구문._

_} else if\(if에서 조건이 거짓일 때 다음으로 검사할 조건문\) {_

_조건이 참일 경우 실행할 구문._

_} else {_

_위의 조건들 외의 모든 상황에서 실행할 구문._

_}_

**이런 형태가 있을 수 있다.**

##### 

이번에는 if문 외의 조건문에 대해 배워보자.

#### **switch case**라는 조건문도 우리는 사용할 수 있다. {#switch-case라는-조건문도-우리는-사용할-수-있다}

이번에도 예제를 통해 사용법을 알아보자.

```
#include<stdio.h>
int main( void ){
    int num1 = 0;
    int num2 = 0;
    int value = 0;
    char op;

    printf( "수식을 입력하시오 : " );
    scanf( "%d %c %d", &num1, &op, &num2 );

    switch(op){  //char a의 값에 따라서 case를 설정
    case '+': //char a의 값이 +일경우 +연산을 한다.
        value = num1 + num2;
        printf( "%d %c %d = %d", num1, op, num2, value );
        break;
    case '-': //char a의 값이 -일경우 -연산을 한다.
        value = num1 - num2;
        printf( "%d %c %d = %d", num1, op, num2, value );
        break;
    case '*':  //char a의 값이 *일경우 *연산을 한다.
        value = num1 * num2;
        printf( "%d %c %d = %d", num1, op, num2, value );
        break;
    case '/':  //char a의 값이 /일경우 /연산을 한다.
        printf( "%d %c %d = %lf", num1, op, num2, (double)num1/num2 );
        break;
    default:
        printf( "계산할 수 없음" );
        break;
    }

    return 0;
}
```

위의 코드는 간단한 사칙연산 계산기 코드이다.

###### 실행화면은 다음과 같다. {#실행화면은-다음과-같다}

###### ![](https://newrim.gitbooks.io/c-study_icewall/content/assets/스크린샷 2017-04-04 오전 12.48.25.png)

switch case는

switch\(변수\) &lt;- 요기에 들어가는 변수의 값에 따라 case를 나눠실행하는 문법이다.

위의 예제를 보면 operator라는 char형 변수를 입력 받은 후 그 값에 따라 case를 나누어 연산하고 있다.

이때 각 case문 마다 break를 쓰지 않으면 해당하는 케이스에 들어간 후 그 구문부터 밑에 까지 쭉 실행한다.

꼭 break로 switch문을 탈출해야 한다.

만약 내가 \*의 case 구문에서 break를 뺀다면,

###### ![](https://newrim.gitbooks.io/c-study_icewall/content/assets/스크린샷 2017-04-04 오전 1.02.50.png)

이런 이상한 결과가 나오게 된다. break로 빠져나가질 못했으니, 나누기 연산 까지 실행한다. operator 의 값은 그대로이니까

4 \* 3 = 1.333333 이라는 잘못된 출력이 덧붙여 나온다.

###### 

---

###### 

배우는 내용이 좀 많은 것 같다고 느껴지면 기분 탓이다...

이제, 마지막으로 지난 시간에 배운 기본 연산자에 이어 추가적으로 기타 연산자들을 배워보자.

![](https://newrim.gitbooks.io/c-study_icewall/content/assets/스크린샷 2017-04-04 오전 1.11.51.png)&lt; 부터 &gt;= 까지는 표를 읽고 이해할 수 있을거라 생각하고 넘어간다.

###### 

&&부터는 조금 생소하게 느껴질 것이다.

&&, \|\| , ! 모두 조건문을 작성할 때 여러 조건을 복합적으로 넣고 싶을 때 사용하는 연산자 들이다. 이런 것들을**논리 연산자**라고 한다.

###### 

1. &&연산자 : 예\) a==1 &&b==2 // A = 1 , B = 2

   ```
   결과) 1  && 연산자는 두개의 조건을 모두 만족을 해야 1\(True\) 이 반환됨

   해석) a가 1 이고, b가 2 면 1\(true\)
   ```

2. \|\| 연산자 : 예\) a==10 \|\| b==90 // A = 10 , B = 20

   ```
   결과) 1 || 연산자는 두개의 조건중 한가지라도 만족이 되면 1(True) 이 반환됨

   해석) a가 10 이거나, b가 90 이면 1\(true\)
   ```

3. ! 연산자 : 예\) !a A = 1;

   ```
   결과) 0  1(True) 이므로, 0\(False\) 반환됨.

   해석) a값이 true면 false를 반환하고 false 이면 true를 반환 !(not)연산자
   ```

##### 

그 다음의 & 부터 &gt;&gt; 까지는 비트 연산자 라고 한다.**비트 연산자**는 1비트 단위로 연산하는 것들을 말한다.

int 형 변수 n 에 9가 들어있다고 해보자.

이걸 4byte\(32bit\)짜리 이진수로 표현하면,

이다. 9 를 이진수로 표현하면, 1001이다. 그리고 메모리에서 정수 값을 저장 할때는 맨 앞에**비트**를 정수의 부호를 표현하기 비트로 정한다.

양수는 0을 집어넣고, 음수는 1을 집어넣는다.

n에는 +9가 저장되어있기 때문에 00000000000000000000000000001001로 표현되는 것이다.

&가 두개 있으면 논리 연산자에서 두 가지 조건이 모두 참\(1\) 일 때, 참\(1\) 이 반환되었다.

&하나 짜리도 비슷한 기능을 한다.

int 형 변수 n2에 4가 들어있다 할 때, 4도 4byte 이진수로 표현하면, 00000000000000000000000000000100 이다.

만약 num1과 num2를 &연산 한다면, \( num1&num2 \)

이 두 정수를 한 비트씩 비교를 할 때 두 비트 다 1이면 1을 반환 아니면 0을 반환한다.

int res = num1&num2;

```
  00000000000000000000000000001001
& 00000000000000000000000000000100
= 00000000000000000000000000000000
```

이렇게 하면 res에는 0 값이 들어갈 것 이다.

```
#include<stdio.h>

int main(void) {
    int num1 = 9;
    int num2 = 4;
    int res = num1 & num2 ;
    printf("%d\n",res);
    return 0;
}
```

위 코드를 실해하면, 다음과 같이 실행결과를 확인할 수 있다.

![](https://newrim.gitbooks.io/c-study_icewall/content/assets/스크린샷 2017-04-04 오전 1.55.41.png)

##### 

다른 비트 연산자들도 마찬가지로 한 비트씩 연산하면 된다.

\| 도 \|\|와 비슷한 의미를 가지므로 비트끼리 연산할 때, 두 비트 중 하나라도 1 이면 1을 반환한다.

```
  00000000000000000000000000001001
| 00000000000000000000000000000100
= 00000000000000000000000000001101
```

###### 

~역시 논리연산자에서의 ! 와 비슷한 의미를 가지므로, 1일때는 0을 0일때는 1을 반환한다.

```
  00000000000000000000000000001001
                 ! 
= 11111111111111111111111111110110
```

###### 

그리고 ^는 각 비트끼리 연산을 할때 두 비트가 다르면 1을 반환, 같으면 0을 반환한다.

```
  00000000000000000000000000001001
^ 00000000000000000000000000000100
= 00000000000000000000000000001101
```

###### 

이제 &lt;&lt; , &gt;&gt; 에 대해서만 알아보면 된다.

&lt;&lt;는 생긴 그대로 비트를 왼쪽으로 이동시키고, &gt;&gt;는 비트를 오른쪽으로 이동시킨다는 뜻이다.

&lt;&lt;n 이렇게 작성하면, n번 만큼 비트를 왼쪽으로 이동시키겠다는 의미이다.

비트를 왼쪽으로 이동시키면 곱하기 2한 것과 같고, 오른쪽으로 이동시키면 나누기 2한 것과 같다.

이진수로 표현되어 있기 때문이다.

```
    00000000000000000000000000001001
                  <<2 
=   00000000000000000000000000100100
```

시프트 연산 예제 코드

```
#include<stdio.h>

int main(void) {
    int num1 = 9;
    int num2 = 4;
    int res1 = num1 << 1;
    int res2 = num2 >> 2;
    printf("%d %d\n",res1, res2);
    return 0;
}
```

위 코드를 실행하면, 아래와 같은 결과를 확인할 수 있다.

![](https://newrim.gitbooks.io/c-study_icewall/content/assets/스크린샷 2017-04-04 오전 2.19.54.png)

###### 

수업 끝 ㅇ&lt;-&lt; ..... \(작성자의 온기가 남아있는 글입니다...\)

